\section{Search}
\label{section:search}

The core function of \textit{GESTALT} is to perform last-mile search given partial or uncertain information.
The user is assumed to know the general region of interest and some information about the objects at the location they seek.
Under these conditions, the search problem can be framed in several ways, which we describe below in increasing order of complexity and utility.

\subsection{Membership Search}

\subsubsection{\textbf{Exact membership search}}
The simplest search function in \emph{GESTALT} (Algorithm \ref{alg:search}) takes a set of query terms representing objects the user knows are at a location, and performs the appropriate look-ups and set intersections to determine which locations are a match for containing \textit{all} those objects.

\begin{algorithm}
    \caption{Membership Search}\label{alg:search}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Search}{$QT$,$II$}
            \State{$Locs$ $\leftarrow$ []}
            \For{Each $q$ in $QT$}
                \State{Retrieve set of Locations $II$[$q$] and add to $Locs$}
            \EndFor
            \State{\textbf{return} intersection of sets of Locations in $Locs$}
            \EndProcedure
    \end{algorithmic}
\end{algorithm}

%A \textit{set membership problem} is the most straightforward and most efficient. Given a set of locations, each of which has a set of objects it 'owns' and a set of objects in the search term, which locations have complete coverage of the search set.
\subsubsection{\textbf{Ranked membership search}}
When the exact membership search returns a large number of hits, such as for a broad query (i.e. Which locations have a tree and a bench?) the ranking of those locations can help narrow the results. Using Algorithm \ref{alg:rank}, we aggregate the confidence scores from the object tagging and ownership assignment stages to determine the overall likelihood that a given location contains the object of interest. These scores are then aggregated per location for the relevant query objects, and the final scores determine the ranking of the results. 

\begin{algorithm}[H]
    \caption{Ranked Membership Search}\label{alg:rank}
    \begin{algorithmic}
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{Rank}{$S$,$QT$,$II$}\Comment{$S$ results from $Q$ query terms in $II$}
            \State{$LR$ $\leftarrow$ Empty Ordered Dictionary}\Comment{\textbf{L}ocation \textbf{R}ank}
            \For{Each $L$ in $S$}\Comment{\textbf{L}ocation}
                \State{$p$ $\leftarrow$ 1}%\Comment{Probability location correct}
                \For{$O$ in $QT$}
                    %\State{$OP$ = Prob of Obj@Locin $II$}\Comment{$OP$ = \textbf{O}bject \textbf{P}robability}
                    \State{$p$ $\leftarrow$ $p$x$OP$}\Comment{$OP$ = \textbf{O}bject \textbf{P}robability}
                \EndFor
                \State{$LR$[$L$] $\leftarrow$ $p$}
            \EndFor
            \State{\textbf{return} $LR$ ordered most to least likely}
        \EndProcedure
    \end{algorithmic}
\end{algorithm}


\subsubsection{\textbf{Fuzzy Membership Search}}
When the exact membership search returns no matching locations, we use a fuzzy search procedure (Algorithm \ref{alg:fuzzySearch}) to find a set of partial match locations based on the most discriminative object(s) in the list of query terms provided. 
The most discriminative terms are emphasized since rare objects are memorable and more uniquely identify locations than common objects do.

\begin{algorithm}
    \caption{Fuzzy Membership Search}\label{alg:fuzzySearch}
    \begin{algorithmic}[2]
        \State{\textit{\textbf{QT} a list of query terms to search for}}
        \State{\textit{\textbf{II} an inverted index with objects as keys and locations as values}}
        \State{- - - - -}
        \Procedure{fuzzySearch}{$QT$,$II$}
            \State{$S$ $\leftarrow$ \textbf{II.SEARCH}($QT$)}
            \If{$S$ is Empty}
                \State{$q$ $\leftarrow$ Pop most discriminative term from $QT$}
                \State{$S$ $\leftarrow$ \textbf{$II$.SEARCH}($QT$)}
                \If{$S$ is not Empty}
                    \State{Skip to Line 6}
                \Else
                    \State{$S$ $\leftarrow$ \textbf{II.SEARCH}($QT$.remove($q$)}
                \EndIf
            \EndIf
            \If{$S$ has more than 1 item}
                \State{\textbf{return} \textbf{$II$.RANK($S$,$Q$)}}
            \EndIf
        \EndProcedure
    \end{algorithmic}
\end{algorithm}

%Fuzzy search begins with the most discriminative query term (based on counts maintained by the inverted index) and proceeds by adding query terms successively until the set intersection returns no locations matching all the criteria, at which point it walks back by one term and returns the prvious set of locations, which is the closest match.

%\subsubsection{Scalability}


%on several queries over the Washington D.C. dataset to demonstrate the scalability of the membership search functionality of \emph{GESTALT}. 

%\nrscomment{Kent, plot num locations vs time for fuzzy search runs}
